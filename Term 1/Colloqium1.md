# Вопросы
<details><summary>1. Оценка сложности алгоритма по времени</summary>
  А всё
</details>
<details><summary>2. Оценка сложности алгоритма по памяти</summary>
</details>
<details><summary>3. Сортировка вставками</summary>
  <center><h1> Сортировка вставками </h1></center>
  <br><h2> Асимптотика алгоритма </h2><br>
 
  <h3>

| Оценка     | Лучший случай | Средний случай | Худший случай |
|:----------:|:-------------:|:--------------:|:-------------:|
| По времени | O(n)          | O(n^2)         | O(n^2)        |
| По памяти  | O(1)          | O(1)           | O(1)          |

  Лучший случай достигается, при изначально отсортрованном массиве.
  
  Инвариант: на j-й итерации цикла массив [0..(j-1)] состоит из исходных элементов, расположенных в порядке возрастания.

  На первой итерации алгоритм состоит из 1 исходного элемента, расположенного по возрастанию.

  <h3>    
  <img src = "source/InsertionSort.gif">

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
<details><summary>4. Сортировка слиянием</summary>
  <center><h1> Сортировка Слиянием </h1></center>
  <br><h2> Асимптотика алгоритма </h2><br>

  <h3>

| Оценка     | Лучший случай | Средний случай | Худший случай |
|:----------:|:-------------:|:--------------:|:-------------:|
| По времени | O(n * log(n)) | O(n * log(n))  | O(n * log(n)) |
| По памяти  | O(n)          | O(n)           | O(n)          |
  <br>По врмени: n тратится на слияние log(n) на зазбиению через вызов рекурсии. 

  !Необходим дополнительный массив при слиянии.
  <h3>    
  <img src = "source/MergeSort.png">
  <br><center><h1> Реализация </h1></center><br>

```c++
  
```
</details>
<details><summary>5. Быстрая сортировка</summary>

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
<details><summary>6. Сортировка подсчетом</summary>

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
<details><summary>7. Цифровая сортировка</summary>

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
<details><summary>8. Стек</summary>
  <center><h1> Стек </h1></center>
  <br><center><h2> Оценка операций структуры по времени </h2></center><br>
  <h3>

| Удаление | Добавление | Поиск |
|:--------:|:----------:|:-----:|
|   O(1)   |    O(1)    |  O(n) |


  <br> <center> Описание структуры </center> <br>
  <p>Stack - абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»). </p>

  <p>Если проще, то Stack можно представить в виде стопки книг (для того, ведь чтобы добраться до определенной книги необходимо убрать сверху все остальные). </p> 

  <p>Стек состоит из ячеек(в примере — это книги), которые представлены в виде структуры, содержащей какие-либо данные и указатель типа данной структуры на следующий элемент.</p>

  <h3><br>   
  <img src = "source/Stack.gif">

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```
  
</details>
<details><summary>9. Очередь</summary>



  <br><center><h1> Реализация </h1></center><br>

```c++
  
```
</details>
<details><summary>10. Односвязный список</summary>

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
<details><summary>11. Двусвязный список</summary>

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
<details><summary>12. Циклический список</summary>

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
<details><summary>13. Стек на списках</summary>

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
<details><summary>14. Очередь на списках</summary>

  <br><center><h1> Реализация </h1></center><br>

```c++
  
```

</details>
